
from fastapi import APIRouter, HTTPException, Request
import traceback
from fastapi.responses import HTMLResponse, RedirectResponse
from pydantic import BaseModel
from fastapi.templating import Jinja2Templates

import os, io, sys
import pandas as pd
import numpy as np
import json
import re

from .upload import session_store   # import to use the generated session ID from upload
from api_training2.config import GEMINI_API_KEY




templates = Jinja2Templates(directory="app_quiksight/templates")



if not GEMINI_API_KEY:
    raise ValueError("GEMINI_API_KEY is missing")

router = APIRouter()









@router.get("/chat", response_class = HTMLResponse)
async def chat_page(request : Request, sid : str):


    
    if sid not in session_store:    # at this point, session store has now been populated
        return RedirectResponse(url="/", status_code=303)

    
    
    session_data = session_store[sid]
    dataframe = session_data["df"]
    filename = session_data["file_name"]
    filesize = session_data["file_size"]
    file_extension = os.path.splitext(filename)[1]

    upload_date = session_data["upload_date"]
    upload_time = session_data["upload_time"]
    columns = session_data["columns"]


    
    return templates.TemplateResponse("chat.html", {
        "request" : request,
        "session_id" : sid,

        # File information
        "file_name": filename,
        "file_size" : filesize,
        "file_extension": file_extension,
        "upload_date": upload_date,
        "upload_time": upload_time,
        "num_rows" : len(dataframe),
        "num_columns" : len(dataframe.columns),
        "columns" : columns,

        "preview_rows" : session_data["preview_rows"]
    })




def dataframe_to_styled_html(df: pd.DataFrame, max_rows=10):
    """Convert a Pandas DataFrame into a styled Tailwind/DaisyUI HTML table."""
    # Limit rows for readability (optional)
    df_preview = df.head(max_rows)

    # Build table manually with Jinja-like HTML
    thead = "<thead class='bg-gray-50 text-gray-600 font-medium'><tr>"
    for col in df_preview.columns:
        thead += f"<th>{col}</th>"
    thead += "</tr></thead>"

    tbody = "<tbody>"
    for _, row in df_preview.iterrows():
        tbody += "<tr>"
        for col in df_preview.columns:
            val = row[col]
            if pd.isna(val) or val == "":
                cell = '<span class="text-gray-400 italic">N/A</span>'
            elif len(str(val)) > 60:
                safe_val = str(val).replace('"', '&quot;')
                cell = f"""
                <div class="tooltip tooltip-bottom text-left" data-tip="{safe_val}">
                    <span class="truncate max-w-xs block">{safe_val}</span>
                </div>
                """
            else:
                cell = str(val)
            tbody += f"<td>{cell}</td>"
        tbody += "</tr>"
    tbody += "</tbody>"

    return f"""
    <div class="w-full max-w-7xl mx-auto bg-white rounded-2xl shadow-md p-2 mt-2">
        <div class="overflow-x-auto">
            <table class="table table-zebra table-pin-rows">
                {thead}
                {tbody}
            </table>
        </div>
    </div>
    """






# FUNCTION TO EXECUTE THE CODE GENERATED BY THE MODEL ON THE DATASET
def execute_user_code(code: str, df: pd.DataFrame):
    local_env = {"df": df, "pd": pd, "np": np}

    stdout_buffer = io.StringIO()   # Captures print outputs in the code to the stdout_buffer(memory buffer) variable instead of console
    sys.stdout = stdout_buffer      # points to console normally but this time we send all print() outputs to the in-memory buffer we made(stdout_buffer)

    try:
        exec(code, {}, local_env)
        # executes a given code
        # globals is left blank, so only context of the execution is the locals
        # locals is the only thing the AI/code can access: locals = local_env â†’ AI can only access df, pd, np
    except Exception as e:
        result = str(e)     # any error is stored in the 'result' variable
    else:
        result = stdout_buffer.getvalue()   # If execution succeeds, grab everything the code print()ed out. The results of the execution
    finally:
        sys.stdout = sys.__stdout__         # resets the stdout; sends future print statements back to the console output(not buffer again). Important so we can debug and use print statements normally


    return {
        "response": {
            "text": "Execution finished.",
            "code": code,
            "execution_results": result,
        }
    }



def clean_raw_json_response(ai_response):
        ai_response = ai_response.strip()
        if ai_response.startswith("```"):
            # This regex now also handles optional 'json' language specifier
            ai_response = re.sub(r"^```(json)?\n?", "", ai_response) 
            ai_response = re.sub(r"\n?```$", "", ai_response)
        ai_response = ai_response.strip()



        try:
            json_decoder = json.JSONDecoder()
            parsed_response, _ = json_decoder.raw_decode(ai_response)
            print("\n\n\n\AI JSON:\n\n", parsed_response)
        except json.JSONDecodeError as e:
            print("JSON parse error:", e, "\nRaw text was:", ai_response)
            raise HTTPException(status_code=500, detail="AI returned invalid JSON")
        
        return parsed_response





class ChatRequest(BaseModel):
    message: str

@router.post("/chat")
async def chat_endpoint(req: ChatRequest, sid: str):
    if sid not in session_store:
        raise HTTPException(status_code=404, detail="Conversation not found")

    try:
        
        session_data = session_store[sid]
        chat_session = session_data["chat_session"]
        response = chat_session.send_message(req.message)
        raw_text = response.candidates[0].content.parts[0].text

        cleaned_response = clean_raw_json_response(raw_text)

        code = cleaned_response["response"].get("code")


        if code:
            exec_result = execute_user_code(code, session_data["df"])
            execution_results = exec_result["response"].get("execution_results", "")
            



           
            if "<table" in execution_results:
                try:
                    # Convert HTML string into DataFrames safely
                    dfs = pd.read_html(io.StringIO(execution_results))
                    if dfs:
                        # Style ALL tables, not just the first
                        styled_tables = [dataframe_to_styled_html(df) for df in dfs]
                        execution_results = "".join(styled_tables)
                except Exception as e:
                    print("Table styling failed:", e)



            # Replace placeholder and keep results
            ai_text = cleaned_response["response"]["text"]
            cleaned_response["response"]["text"] = ai_text.replace("{{EXECUTION_RESULT}}", execution_results)
            cleaned_response["response"]["execution_results"] = execution_results
            cleaned_response["response"]["code"] = code

        return cleaned_response
    
    # Catch any errors that comes when sending/receiving messages
    except Exception as e:
        print("ERROR in chat endpoint:", e)
        print(traceback.format_exc())
        raise HTTPException(status_code=500, detail=str(e))



