
# from fastapi import APIRouter, HTTPException, Request
# import traceback
# from fastapi.responses import HTMLResponse, RedirectResponse
# from pydantic import BaseModel
# from fastapi.templating import Jinja2Templates

# import os, io, sys
# import pandas as pd
# import numpy as np
# import json

# from .upload import session_store   # import to use the generated session ID from upload
# from api_training2.config import GEMINI_API_KEY


# from google.genai import types

# templates = Jinja2Templates(directory="app_quiksight/templates")



# if not GEMINI_API_KEY:
#     raise ValueError("GEMINI_API_KEY is missing")

# router = APIRouter()



# from datetime import datetime


# # Display the chat.html page
# @router.get("/chat", response_class = HTMLResponse)
# async def chat_page(request : Request, sid : str):


    
#     if sid not in session_store:    # at this point, session store has now been populated
#         return RedirectResponse(url="/", status_code=303)

    
    
#     session_data = session_store[sid]
#     dataframe = session_data["df"]
#     filename = session_data["file_name"]
#     filesize = session_data["file_size"]
#     file_extension = os.path.splitext(filename)[1]

#     upload_date = session_data["upload_date"]
#     upload_time = session_data["upload_time"]
#     columns = session_data["columns"]


    
#     return templates.TemplateResponse("chat.html", {
#         "request" : request,
#         "session_id" : sid,

#         # File information
#         "file_name": filename,
#         "file_size" : filesize,
#         "file_extension": file_extension,
#         "upload_date": upload_date,
#         "upload_time": upload_time,
#         "num_rows" : len(dataframe),
#         "num_columns" : len(dataframe.columns),
#         "columns" : columns,

#         "preview_rows" : session_data["preview_rows"],

#         # ===================================================
#         "cache_buster": datetime.now().timestamp()
#     })



# # Styling for when the model returns a dataframe/table
# def dataframe_to_styled_html(df: pd.DataFrame, max_rows=10):
#     """Convert a Pandas DataFrame into a styled Tailwind/DaisyUI HTML table."""
#     # Limit rows for readability (optional)
#     df_preview = df.head(max_rows)

#     # Build table manually with Jinja-like HTML
#     thead = "<thead class='bg-gray-50 text-gray-600 font-medium'><tr>"
#     for col in df_preview.columns:
#         thead += f"<th>{col}</th>"
#     thead += "</tr></thead>"

#     tbody = "<tbody>"
#     for _, row in df_preview.iterrows():
#         tbody += "<tr>"
#         for col in df_preview.columns:
#             val = row[col]
#             if pd.isna(val) or val == "":
#                 cell = '<span class="text-gray-400 italic">N/A</span>'
#             elif len(str(val)) > 60:
#                 safe_val = str(val).replace('"', '&quot;')
#                 cell = f"""
#                 <div class="tooltip tooltip-bottom text-left" data-tip="{safe_val}">
#                     <span class="truncate max-w-xs block">{safe_val}</span>
#                 </div>
#                 """
#             else:
#                 cell = str(val)
#             tbody += f"<td>{cell}</td>"
#         tbody += "</tr>"
#     tbody += "</tbody>"

#     return f"""
#     <div class="w-full max-w-7xl mx-auto bg-white rounded-2xl shadow-md p-2 mt-2">
#         <div class="overflow-x-auto">
#             <table class="table table-zebra table-pin-rows">
#                 {thead}
#                 {tbody}
#             </table>
#         </div>
#     </div>
#     """






# # FUNCTION TO EXECUTE THE CODE GENERATED BY THE MODEL ON THE DATASET
# def execute_user_code(code: str, df: pd.DataFrame):
#     local_env = {"df": df.copy(), "pd": pd, "np": np}

#     stdout_buffer = io.StringIO()   # Captures print outputs in the code to the stdout_buffer(memory buffer) variable instead of console
#     sys.stdout = stdout_buffer      # points to console normally but this time we send all print() outputs to the in-memory buffer we made(stdout_buffer)

#     try:
#         exec(code, {}, local_env)
#         # executes a given code
#         # globals is left blank, so only context of the execution is the locals
#         # locals is the only thing the AI/code can access: locals = local_env â†’ AI can only access df, pd, 
        
#         modified_df = local_env.get('df')
#         # Update the session's DataFrame if it was modified
#         if modified_df is not None and not modified_df.equals(df):
#             return {
#                 "response": {
#                     "text": "Execution finished.",
#                     "code": code,
#                     "execution_results": stdout_buffer.getvalue(),
#                 },
#                 "modified_df": modified_df
#             }


#     except Exception as e:
#         result = str(e)     # any error is stored in the 'result' variable
#     else:
#         result = stdout_buffer.getvalue()   # If execution succeeds, grab everything the code print()ed out. The results of the execution
#     finally:
#         sys.stdout = sys.__stdout__         # resets the stdout; sends future print statements back to the console output(not buffer again). Important so we can debug and use print statements normally


#     return {
#         "response": {
#             "text": "Execution finished.",
#             "code": code,
#             "execution_results": result,
#         }
#     }



# # Validate the model's response to make sure it is in proper JSON
# def clean_raw_json_response(ai_response: str):
#     """
#     Aggressively finds and parses a JSON object from a potentially messy string.
#     """
#     # Find the start of the JSON object
#     json_start_index = ai_response.find('{')
#     if json_start_index == -1:
#         print("ERROR: No JSON object found in AI response.")
#         raise HTTPException(status_code=500, detail="AI response did not contain valid JSON.")

#     # Find the end of the JSON object
#     # This is tricky because of nested objects. We'll look for the last closing brace.
#     json_end_index = ai_response.rfind('}')
#     if json_end_index == -1:
#         print("ERROR: No closing brace for JSON object found.")
#         raise HTTPException(status_code=500, detail="AI response did not contain valid JSON.")

#     # Extract the potential JSON string
#     potential_json = ai_response[json_start_index : json_end_index + 1]

#     try:
#         # Try to parse the extracted string
#         parsed_response = json.loads(potential_json)
#         print("\n\nSuccessfully Parsed AI JSON:\n\n", parsed_response)
#         return parsed_response
#     except json.JSONDecodeError as e:
#         print("JSON parse error:", e)
#         print("--- Raw AI Text Was ---")
#         print(ai_response)
#         print("--- Attempted to Parse ---")
#         print(potential_json)
#         print("-----------------------")
#         raise HTTPException(status_code=500, detail="AI returned invalid JSON after cleaning.")




# class ChatRequest(BaseModel):
#     message: str

# @router.post("/chat")
# async def chat_endpoint(req: ChatRequest, sid: str):
#     if sid not in session_store:
#         raise HTTPException(status_code=404, detail="Conversation not found")

#     try:
        
#         session_data = session_store[sid]
#         chat_session = session_data["chat_session"]

#         response = chat_session.send_message(req.message)
        
#         response_data = json.loads(response.text)
#         ai_text = response_data[0]['text_explanation']
#         code = response_data[0]['code_generated']
#         should_execute = response_data[0]['should_execute']

#         print(response_data)


#         execution_results = ""
#         if should_execute and code:
#             exec_result = execute_user_code(code, session_data["df"])

#             if "modified_df" in exec_result:
#                 session_data["df"] = exec_result["modified_df"]

#             execution_results = exec_result["response"].get("execution_results", "")
            




#             if "<table" in execution_results:
#                 try:
#                     # Convert HTML string into DataFrames safely
#                     dfs = pd.read_html(io.StringIO(execution_results))
#                     if dfs:
#                         # Style ALL tables, not just the first
#                         styled_tables = [dataframe_to_styled_html(df) for df in dfs]
#                         execution_results = "".join(styled_tables)
#                 except Exception as e:
#                     print("Table styling failed:", e)


    
#         return {
#             "response" : {
#             "text" : ai_text,
#             "code" : code,
#             "execution_results" : execution_results
#         }}
    
#     # Catch any errors that comes when sending/receiving messages
#     except Exception as e:
#         print("ERROR in chat endpoint:", e)
#         print(traceback.format_exc())
#         raise HTTPException(status_code=500, detail=str(e))























import warnings
warnings.simplefilter(action='ignore', category=FutureWarning)

from fastapi import APIRouter, HTTPException, Request
import traceback
from fastapi.responses import HTMLResponse, RedirectResponse, StreamingResponse
from pydantic import BaseModel
from fastapi.templating import Jinja2Templates
import datetime

import os, io, sys
import pandas as pd
import numpy as np
import json
import uuid


from .upload import session_store 
# from api_training2.config import GEMINI_API_KEY

templates = Jinja2Templates(directory="app_quiksight/templates")

router = APIRouter()

# --- STYLING & DOWNLOAD BUTTON ---
def dataframe_to_styled_html(df: pd.DataFrame, download_id: str = None, max_rows=10):
    """Convert a Pandas DataFrame into a styled HTML table with a download button."""
    # Limit rows for display
    df_preview = df.head(max_rows)

    thead = "<thead class='bg-gray-50 text-gray-600 font-medium'><tr>"
    for col in df_preview.columns:
        thead += f"<th>{col}</th>"
    thead += "</tr></thead>"

    tbody = "<tbody>"
    for _, row in df_preview.iterrows():
        tbody += "<tr>"
        for col in df_preview.columns:
            val = row[col]
            if pd.isna(val) or val == "":
                cell = '<span class="text-gray-400 italic">N/A</span>'
            elif len(str(val)) > 60:
                safe_val = str(val).replace('"', '&quot;')
                cell = f'<div class="tooltip tooltip-bottom text-left" data-tip="{safe_val}"><span class="truncate max-w-xs block">{safe_val}</span></div>'
            else:
                cell = str(val)
            tbody += f"<td>{cell}</td>"
        tbody += "</tr>"
    tbody += "</tbody>"

    # Download Button Logic
    download_html = ""
    if download_id:
        download_html = f"""
        <div class="flex justify-between items-center mb-2 px-1">
            <span class="text-xs text-gray-500 font-mono"></span>
            <a href="/chat/download/{download_id}" target="_blank" class="btn btn-sm btn-outline btn-accent gap-2">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
                </svg>
                Download CSV
            </a>
        </div>
        """

    return f"""
    <div class="w-full max-w-7xl mx-auto bg-white rounded-xl shadow-sm border border-gray-200 p-3 mt-3">
        {download_html}
        <div class="overflow-x-auto">
            <table class="table table-zebra table-pin-rows table-xs sm:table-sm">
                {thead}
                {tbody}
            </table>
        </div>
        <div class="text-xs text-gray-400 mt-2 text-center">
            Displaying out of {len(df_preview)} of {len(df)} rows
        </div>
    </div>
    """

# --- EXECUTION ENGINE ---
def execute_user_code(code: str, session_data: dict):
    df = session_data["df"]
    
    # Helper function available to the AI
    def display_table(data_frame):
        if not isinstance(data_frame, pd.DataFrame):
            print(data_frame)
            return

        # Generate ID and Save
        dl_id = str(uuid.uuid4())
        if "downloads" not in session_data:
            session_data["downloads"] = {}
            
        session_data["downloads"][dl_id] = data_frame.copy()
        
        # Print HTML
        print(dataframe_to_styled_html(data_frame, download_id=dl_id))

    # Sandbox environment
    local_env = {
        "df": df.copy(), 
        "pd": pd, 
        "np": np, 
        "display_table": display_table
    }

    stdout_buffer = io.StringIO()
    sys.stdout = stdout_buffer

    try:
        # Using a basic whitelist for builtins so AI can't just import whatever it wants (security)
        safe_builtins = {
            "len": len, "print": print, "range": range, "int": int, 
            "float": float, "str": str, "list": list, "dict": dict, 
            "round": round, "sum": sum, "min": min, "max": max,
            "abs": abs, "enumerate": enumerate, "zip": zip, "Exception" : Exception
        }
        
        exec(code, {"__builtins__": safe_builtins}, local_env)
        
        modified_df = local_env.get('df')
        # Only return modified_df if it actually changed
        if modified_df is not None and not modified_df.equals(df):
             return {
                "response": {"execution_results": stdout_buffer.getvalue()},
                "modified_df": modified_df
            }

    except Exception as e:
        print(traceback.format_exc())  # Terminal sees this
        print(f"<div class='alert alert-error text-sm mt-2'><span>Oops! Something went wrong. Please try sending your message again.</span></div>")

    finally:
        sys.stdout = sys.__stdout__

    return {
        "response": {
            "execution_results": stdout_buffer.getvalue(),
        }
    }

# --- ROUTES ---

@router.get("/chat", response_class=HTMLResponse)
async def chat_page(request: Request, sid: str):
    if sid not in session_store:
        return RedirectResponse(url="/", status_code=303)
    
    session_data = session_store[sid]
    
    # Ensure downloads dict exists (backward compatibility)
    if "downloads" not in session_data:
        session_data["downloads"] = {}

    return templates.TemplateResponse("chat.html", {
        "request": request,
        "session_id": sid,
        "file_name": session_data["file_name"],
        "file_size": session_data["file_size"],
        "file_extension": os.path.splitext(session_data["file_name"])[1],
        "upload_date": session_data["upload_date"],
        "upload_time": session_data["upload_time"],
        "num_rows": len(session_data["df"]),
        "num_columns": len(session_data["df"].columns),
        "columns": session_data["columns"],
        "preview_rows": session_data["preview_rows"],
        "cache_buster": datetime.datetime.now().timestamp()
    })

class ChatRequest(BaseModel):
    message: str

@router.post("/chat")
async def chat_endpoint(req: ChatRequest, sid: str):
    if sid not in session_store:
        raise HTTPException(status_code=404, detail="Conversation not found")

    try:
        session_data = session_store[sid]
        chat_session = session_data["chat_session"]

        response = chat_session.send_message(req.message)
        
        # Clean JSON parsing
        response_text = response.text.replace('```json', '').replace('```', '')
        try:
            response_data = json.loads(response_text)
        except:
            # Fallback if AI output isn't perfect JSON
            start = response_text.find('[')
            end = response_text.rfind(']') + 1
            response_data = json.loads(response_text[start:end])

        ai_text = response_data[0]['text_explanation']
        code = response_data[0]['code_generated']
        should_execute = response_data[0]['should_execute']
        print(response_data)

        execution_results = ""
        if should_execute and code:
            # Pass session_data to access the downloads dict
            exec_result = execute_user_code(code, session_data)

            if "modified_df" in exec_result:
                session_data["df"] = exec_result["modified_df"]

            execution_results = exec_result["response"].get("execution_results", "")

        return {
            "response": {
                "text": ai_text,
                "code": code,
                "execution_results": execution_results
            }
        }
    except Exception as e:
        print(traceback.format_exc())
        raise HTTPException(status_code=500, detail=str(e))

# NEW: Download Endpoint
@router.get("/chat/download/{download_id}")
async def download_result(download_id: str):
    # Search all sessions for this download ID (simple lookup)
    # In a database app, you'd query by ID.
    found_df = None
    for sid, data in session_store.items():
        if "downloads" in data and download_id in data["downloads"]:
            found_df = data["downloads"][download_id]
            break
    
    if found_df is None:
        raise HTTPException(status_code=404, detail="File not found")

    stream = io.StringIO()
    found_df.to_csv(stream, index=False)
    response = StreamingResponse(iter([stream.getvalue()]), media_type="text/csv")
    response.headers["Content-Disposition"] = "attachment; filename=quiksight_export.csv"
    return response

