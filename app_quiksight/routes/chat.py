
from fastapi import APIRouter, HTTPException, Request
import traceback
from fastapi.responses import HTMLResponse, RedirectResponse
from pydantic import BaseModel
from fastapi.templating import Jinja2Templates

import os, io, sys
import pandas as pd
import numpy as np
import json
import re

from .upload import session_store   # import to use the generated session ID from upload
from api_training2.config import GEMINI_API_KEY




templates = Jinja2Templates(directory="app_quiksight/templates")



if not GEMINI_API_KEY:
    raise ValueError("GEMINI_API_KEY is missing")

router = APIRouter()





# FUNCTION TO EXECUTE THE CODE GENERATED BY THE MODEL ON THE DATASET
def execute_user_code(code: str, df: pd.DataFrame):
    local_env = {"df": df, "pd": pd, "np": np}

    stdout_buffer = io.StringIO()
    sys.stdout = stdout_buffer

    try:
        exec(code, {}, local_env)
    except Exception as e:
        result = str(e)
    else:
        result = stdout_buffer.getvalue()
    finally:
        sys.stdout = sys.__stdout__


    return {
        "response": {
            "text": "Execution finished.",
            "code": code,
            "execution_results": result
        }
    }












@router.get("/chat", response_class = HTMLResponse)
async def chat_page(request : Request, sid : str):


    
    if sid not in session_store:    # at this point, session store has now been populated
        return RedirectResponse(url="/", status_code=303)

    
    
    session_data = session_store[sid]
    dataframe = session_data["df"]
    filename = session_data["file_name"]
    filesize = session_data["file_size"]
    file_extension = os.path.splitext(filename)[1]

    upload_date = session_data["upload_date"]
    upload_time = session_data["upload_time"]
    columns = session_data["columns"]


    
    return templates.TemplateResponse("chat.html", {
        "request" : request,
        "session_id" : sid,

        # File information
        "file_name": filename,
        "file_size" : filesize,
        "file_extension": file_extension,
        "upload_date": upload_date,
        "upload_time": upload_time,
        "num_rows" : len(dataframe),
        "num_columns" : len(dataframe.columns),
        "columns" : columns,

        "preview_rows" : session_data["preview_rows"]
    })








class ChatRequest(BaseModel):
    message: str


@router.post("/chat")
async def chat_endpoint(req: ChatRequest, sid: str):
    if sid not in session_store:
        raise HTTPException(status_code=404, detail="Conversation not found")

    try:
        
        session_data = session_store[sid]
        chat_session = session_data["chat_session"]
        response = chat_session.send_message(req.message)
        raw_text = response.candidates[0].content.parts[0].text


        # Cleaning the JSON respoonse the AI generates
        raw_text = raw_text.strip()
        if raw_text.startswith("```"):
            # This regex now also handles optional 'json' language specifier
            raw_text = re.sub(r"^```(json)?\n?", "", raw_text) 
            raw_text = re.sub(r"\n?```$", "", raw_text)
        raw_text = raw_text.strip()



        try:
            json_decoder = json.JSONDecoder()
            parsed, _ = json_decoder.raw_decode(raw_text)
            print("\n\n\n\AI JSON:\n\n", parsed)
        except json.JSONDecodeError as e:
            print("JSON parse error:", e, "\nRaw text was:", raw_text)
            raise HTTPException(status_code=500, detail="AI returned invalid JSON")
        
        # Execute code if provided
        code = parsed["response"].get("code")


        if code:
            exec_result = execute_user_code(code, session_data["df"])
            execution_results = exec_result["response"].get("execution_results", "")

            # Replace placeholder and keep results
            ai_text = parsed["response"]["text"]
            parsed["response"]["text"] = ai_text.replace("{{EXECUTION_RESULT}}", execution_results)
            parsed["response"]["execution_results"] = execution_results


        return parsed
    

    # Catch any errors that comes when sending/receiving messages
    except Exception as e:
        print("ERROR in chat endpoint:", e)
        print(traceback.format_exc())
        raise HTTPException(status_code=500, detail=str(e))












